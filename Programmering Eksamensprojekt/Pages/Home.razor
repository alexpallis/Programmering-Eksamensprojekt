@page "/"
@using System.Text.Json
@using System.IO
@using Microsoft.AspNetCore.Components
@using Programmering_Eksamensprojekt.Services
@inject IJSRuntime JS
@inject HttpClient Http

<PageTitle>Home</PageTitle>

<script type="text/javascript" async src="MathJax-master/MathJax-master/es5/tex-mml-chtml.js"></script>
<script src="Rerender.js"></script>

@inject MathJaxRenderer mathJaxRenderer;

<h1>Skriv hvad du vil finde bro</h1>
<p>Skriv dit output her:</p>
<input id="outputField" type="text" @bind="Output" @oninput="UpdateSuggestions" list="suggestionsList" />
<datalist id="suggestionsList">
    @foreach (var suggestion in Suggestions)
    {
        <option value="@suggestion"></option>
    }
</datalist>
<p>Skriv dit input her:</p>
<input id="inputField" type="text" @bind="Input" @oninput="UpdateInputSuggestions" list="inputSuggestionsList" />
<datalist id="inputSuggestionsList">
    @foreach (var suggestion in InputSuggestions)
    {
        <option value="@suggestion"></option>
    }
</datalist>
<button id="buttonSearch" @onclick="onSearchButtonClicked">Search</button>

<p>@pString</p>
<p>@p1String</p>
<p>@p2String</p>
<p>@p3String</p>
<p>@p4String</p>
<p>@p5String</p>
<p>@p6String</p>
<p>@p7String</p>
<div @key="@p8String">
    @p8String
</div>
<p>@p9String</p>
<p>@p10String</p>

@code {
    string pString = "";
    string p1String = "";
    string p2String = "";
    string p3String = "";
    string p4String = "";
    string p5String = "";
    string p6String = "";
    string p7String = "";
    string p8String = "";
    string p9String = "";
    string p10String = "";
    List<List<string>> unitGroups = new List<List<string>>();
    List<string> Suggestions = new();
    List<string> InputSuggestions = new();

    private string Output;
    private string Input;
    private Dictionary<string, List<string>> formulaDictionary = new();
    private Dictionary<string, string> nameToNumber = new();

    protected override async Task OnInitializedAsync()
    {
        p2String = "\\( e ^{ i\\pi}+1 = 0 \\)";
        try
        {
            var json = await Http.GetStringAsync($"unitGroups.json?t={DateTime.UtcNow.Ticks}");
            var parsedData = JsonSerializer.Deserialize<Dictionary<string, object>>(json);
            if (parsedData != null && parsedData.ContainsKey("Størrelse"))
            {
                var sizeJsonElement = (JsonElement)parsedData["Størrelse"];
                var sizeDict = JsonSerializer.Deserialize<Dictionary<string, int>>(sizeJsonElement.GetRawText());

                if (sizeDict != null)
                {
                    nameToNumber = sizeDict.ToDictionary(kvp => kvp.Key, kvp => kvp.Value.ToString());
                }
            }
            pString = "JSON virker hype.";
        }
        catch (Exception ex)
        {
            pString = $"Error loading JSON: {ex.Message}";
        }
    }

    private void UpdateSuggestions(ChangeEventArgs e)
    {
        var inputText = e.Value?.ToString() ?? "";
        Suggestions = nameToNumber.Keys
            .Where(name => name.Contains(inputText, StringComparison.OrdinalIgnoreCase))
            .Take(5)
            .ToList();
    }

    private void UpdateInputSuggestions(ChangeEventArgs e)
    {
        var inputText = e.Value?.ToString() ?? "";

        // Split by commas and trim spaces
        var inputParts = inputText.Split(',')
                                  .Select(part => part.Trim())
                                  .Where(part => !string.IsNullOrEmpty(part))
                                  .ToList();

        if (inputParts.Count > 0)
        {
            // Get the last typed value for suggestions
            var lastValue = inputParts.Last();

            // Generate suggestions for the last value only
            InputSuggestions = nameToNumber.Keys
                .Where(name => name.Contains(lastValue, StringComparison.OrdinalIgnoreCase))
                .Take(5)
                .ToList();
        }
        else
        {
            InputSuggestions.Clear();
        }

        // Force re-render to update the dropdown
        StateHasChanged();
    }

    private async Task onSearchButtonClicked()
    {
        if (nameToNumber.TryGetValue(Output, out string outputNumber))
        {
            Output = outputNumber;
        }

        bool Success = false;
        List<string> InputList = Input?.Split(',').Select(i => i.Trim()).ToList() ?? new();
        HashSet<string> HSInput = new HashSet<string>(InputList);
        HashSet<string> requiredUnits = new HashSet<string> { Output };
        requiredUnits.UnionWith(InputList);

        List<List<string>> AlreadyFound = new();
        List<List<string>> FinalEquations = new();
        Success = Search(Output, HSInput, AlreadyFound, FinalEquations, requiredUnits);

        var formulaNames = formulaDictionary
            .Where(kvp => FinalEquations.Any(eq => eq.SequenceEqual(kvp.Value)))
            .Select(kvp => kvp.Key)
            .Distinct()
            .ToList();

        p10String = Success ? "Succes" : "Fail";
        p8String = Success ? string.Join(" ", formulaNames.Select(f => "\\(" + $"{f}" + "\\)")) : "";

        await InvokeAsync(StateHasChanged);
        await Task.Delay(100);
        await CallMathJax();
    }

    private async Task CallMathJax()
    {
        await JS.InvokeVoidAsync("CallMathJax");
    }

    //The search method
    private bool Search(string Output, HashSet<string> HSInput, List<List<string>> AlreadyFound, List<List<string>> FinalEquations, HashSet<string> requiredUnits)
    {
        List<List<string>> matchingFormulas = unitGroups
            .Where(kvp => new HashSet<string>(kvp).IsSubsetOf(requiredUnits) && kvp.Contains(Output))
            .ToList();

        if (matchingFormulas.Count > 0)
        {
            //p3String = string.Join("", matchingFormulas.Select(f => "\\(" + $"{f}" + "\\)" + "   "));
            //p10String = "Succes";
            foreach (var List in matchingFormulas)
            {
                FinalEquations.Add(List);
            }
            return true;
        }



        List<List<string>> groupsWithOutput = unitGroups
        .Where(group => new HashSet<string>(group).Contains(Output))
        .Except(AlreadyFound)
        .ToList();
        unitGroups.Except(AlreadyFound);
        if (groupsWithOutput.Count == 0) return false;

        List<List<string>> matchingGroups2 = new List<List<string>>();
        List<List<string>> matchingGroups3 = new List<List<string>>();

        //Creates a hashset of all the missing variables
        for (int i = 0; i < groupsWithOutput.Count; i++)
        {
            HashSet<string> HSMissingVariables = new HashSet<string>(groupsWithOutput[i]);
            HSMissingVariables.Remove(Output);
            HSMissingVariables.UnionWith(HSInput);
            HSMissingVariables.ExceptWith(HSInput);

            //Checks if any equation from the list contains the missing variables and does not contain any new unknown variables
            for (int j = 0; j < unitGroups.Count; j++)
            {
                if (!groupsWithOutput[i].SequenceEqual(unitGroups[j]))
                {
                    HashSet<string> HSunitGroups = new HashSet<string>(unitGroups[j]);
                    if (HSunitGroups.IsSupersetOf(HSMissingVariables) && HSMissingVariables.Count == 1)
                    {
                        HSunitGroups.ExceptWith(HSMissingVariables);
                        if (HSInput.IsSupersetOf(HSunitGroups))
                        {
                            //Adds the two equations needed to a list
                            matchingGroups2.Add(unitGroups[j]);
                            matchingGroups2.Add(groupsWithOutput[i]);
                        }
                    }
                    else if (HSunitGroups.Overlaps(HSMissingVariables) && HSunitGroups.Count(HSMissingVariables.Contains) == 1)
                    //Adds alle equations with a missing variable, where the rest of the variables are known, to a list.
                    {
                        HSunitGroups.ExceptWith(HSMissingVariables);
                        if (HSInput.IsSupersetOf(HSunitGroups))
                        {
                            matchingGroups3.Add(unitGroups[j]);

                        }
                    }
                }
            }
            HashSet<string> mergedMatchingGroups3 = matchingGroups3.SelectMany(set => set).ToHashSet();
            if (mergedMatchingGroups3.IsSupersetOf(HSMissingVariables))
            {
                matchingGroups3.Add(groupsWithOutput[i]);
            }
            else
            {
                matchingGroups3.Clear();
            }
        }
        if (matchingGroups2.Count > 0)
        //Adds all the found matching equations to the final equations list
        {
            foreach (var group in matchingGroups2)
            {
                FinalEquations.Add(group);
            }
            return true;
        }
        else if (matchingGroups3.Count > 0)
        {
            //Adds all the found matching equations to the final equations list
            foreach (var group in matchingGroups3)
            {
                FinalEquations.Add(group);
            }
            return true;
        }
        else
        {
            p6String = "lol";
            for (int i = 0; i < groupsWithOutput.Count; i++)
            {
                bool allVariablesFound = true;
                //Creates a hashset of all the missing variables
                HashSet<string> HSMissingVariables = new HashSet<string>(groupsWithOutput[i]);
                HSMissingVariables.Remove(Output);
                HSMissingVariables.UnionWith(HSInput);
                HSMissingVariables.ExceptWith(HSInput);
                AlreadyFound.Add(groupsWithOutput[i]);
                foreach (string variable in HSMissingVariables)
                {
                    //searches with the same method to try to find the remaining equations, and leaves out the already found equation.
                    if (!Search(variable, HSInput, AlreadyFound, FinalEquations, requiredUnits))
                    {
                        allVariablesFound = false;
                        AlreadyFound.Remove(groupsWithOutput[i]);
                        //FinalEquations.Clear();
                        break;
                    }
                }
                if (allVariablesFound) {
                    FinalEquations.Add(groupsWithOutput[i]);
                    return true;
                }
                //returns a succes if all variables to an equation with output was found
            }
            return false;
        } 

    }
}